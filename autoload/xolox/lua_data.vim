" Vim auto-load script
" Author: Peter Odding <peter@peterodding.com>
" Last Change: June 15, 2011
" URL: http://peterodding.com/code/vim/lua-ftplugin

" This script contains static user completion data based
" on the Lua 5.1 reference manual and implementation.

" Enable line continuation.
let s:cpo_save = &cpo
set cpoptions-=C

" Keywords. {{{1
let g:xolox#lua_data#keywords = [
      \ { 'word': 'and', 'kind': 'k' },
      \ { 'word': 'break', 'kind': 'k' },
      \ { 'word': 'do', 'kind': 'k' },
      \ { 'word': 'else', 'kind': 'k' },
      \ { 'word': 'elseif', 'kind': 'k' },
      \ { 'word': 'end', 'kind': 'k' },
      \ { 'word': 'false', 'kind': 'k' },
      \ { 'word': 'for', 'kind': 'k' },
      \ { 'word': 'function', 'kind': 'k' },
      \ { 'word': 'if', 'kind': 'k' },
      \ { 'word': 'in', 'kind': 'k' },
      \ { 'word': 'local', 'kind': 'k' },
      \ { 'word': 'nil', 'kind': 'k' },
      \ { 'word': 'not', 'kind': 'k' },
      \ { 'word': 'or', 'kind': 'k' },
      \ { 'word': 'repeat', 'kind': 'k' },
      \ { 'word': 'return', 'kind': 'k' },
      \ { 'word': 'then', 'kind': 'k' },
      \ { 'word': 'true', 'kind': 'k' },
      \ { 'word': 'until', 'kind': 'k' },
      \ { 'word': 'while', 'kind': 'k' } ]

" Global variables. {{{1
let g:xolox#lua_data#globals = [
      \ { 'word': '_G', 'kind': 'v' },
      \ { 'word': '_VERSION', 'kind': 'v' },
      \ { 'word': 'arg', 'kind': 'v' },
      \ { 'word': 'assert()', 'kind': 'f' },
      \ { 'word': 'collectgarbage()', 'kind': 'f' },
      \ { 'word': 'coroutine', 'kind': 'v' },
      \ { 'word': 'debug', 'kind': 'v' },
      \ { 'word': 'dofile()', 'kind': 'f' },
      \ { 'word': 'error()', 'kind': 'f' },
      \ { 'word': 'gcinfo()', 'kind': 'f' },
      \ { 'word': 'getfenv()', 'kind': 'f' },
      \ { 'word': 'getmetatable()', 'kind': 'f' },
      \ { 'word': 'io', 'kind': 'v' },
      \ { 'word': 'ipairs()', 'kind': 'f' },
      \ { 'word': 'load()', 'kind': 'f' },
      \ { 'word': 'loadfile()', 'kind': 'f' },
      \ { 'word': 'loadstring()', 'kind': 'f' },
      \ { 'word': 'math', 'kind': 'v' },
      \ { 'word': 'module()', 'kind': 'f' },
      \ { 'word': 'newproxy()', 'kind': 'f' },
      \ { 'word': 'next()', 'kind': 'f' },
      \ { 'word': 'os', 'kind': 'v' },
      \ { 'word': 'package', 'kind': 'v' },
      \ { 'word': 'pairs()', 'kind': 'f' },
      \ { 'word': 'pcall()', 'kind': 'f' },
      \ { 'word': 'prettyprint()', 'kind': 'f' },
      \ { 'word': 'print()', 'kind': 'f' },
      \ { 'word': 'rawequal()', 'kind': 'f' },
      \ { 'word': 'rawget()', 'kind': 'f' },
      \ { 'word': 'rawset()', 'kind': 'f' },
      \ { 'word': 'require()', 'kind': 'f' },
      \ { 'word': 'select()', 'kind': 'f' },
      \ { 'word': 'setfenv()', 'kind': 'f' },
      \ { 'word': 'setmetatable()', 'kind': 'f' },
      \ { 'word': 'string', 'kind': 'v' },
      \ { 'word': 'table', 'kind': 'v' },
      \ { 'word': 'tonumber()', 'kind': 'f' },
      \ { 'word': 'tostring()', 'kind': 'f' },
      \ { 'word': 'type()', 'kind': 'f' },
      \ { 'word': 'unpack()', 'kind': 'f' },
      \ { 'word': 'xpcall()', 'kind': 'f' } ]

" Standard library identifiers. {{{1
let g:xolox#lua_data#library = [
      \ { 'word': 'coroutine.create()', 'kind': 'f' },
      \ { 'word': 'coroutine.resume()', 'kind': 'f' },
      \ { 'word': 'coroutine.running()', 'kind': 'f' },
      \ { 'word': 'coroutine.status()', 'kind': 'f' },
      \ { 'word': 'coroutine.wrap()', 'kind': 'f' },
      \ { 'word': 'coroutine.yield()', 'kind': 'f' },
      \ { 'word': 'debug.debug()', 'kind': 'f' },
      \ { 'word': 'debug.getfenv()', 'kind': 'f' },
      \ { 'word': 'debug.gethook()', 'kind': 'f' },
      \ { 'word': 'debug.getinfo()', 'kind': 'f' },
      \ { 'word': 'debug.getlocal()', 'kind': 'f' },
      \ { 'word': 'debug.getmetatable()', 'kind': 'f' },
      \ { 'word': 'debug.getregistry()', 'kind': 'f' },
      \ { 'word': 'debug.getupvalue()', 'kind': 'f' },
      \ { 'word': 'debug.setfenv()', 'kind': 'f' },
      \ { 'word': 'debug.sethook()', 'kind': 'f' },
      \ { 'word': 'debug.setlocal()', 'kind': 'f' },
      \ { 'word': 'debug.setmetatable()', 'kind': 'f' },
      \ { 'word': 'debug.setupvalue()', 'kind': 'f' },
      \ { 'word': 'debug.traceback()', 'kind': 'f' },
      \ { 'word': 'io.close()', 'kind': 'f' },
      \ { 'word': 'io.flush()', 'kind': 'f' },
      \ { 'word': 'io.input()', 'kind': 'f' },
      \ { 'word': 'io.lines()', 'kind': 'f' },
      \ { 'word': 'io.open()', 'kind': 'f' },
      \ { 'word': 'io.output()', 'kind': 'f' },
      \ { 'word': 'io.popen()', 'kind': 'f' },
      \ { 'word': 'io.read()', 'kind': 'f' },
      \ { 'word': 'io.size()', 'kind': 'f' },
      \ { 'word': 'io.stderr', 'kind': 'm' },
      \ { 'word': 'io.stdin', 'kind': 'm' },
      \ { 'word': 'io.stdout', 'kind': 'm' },
      \ { 'word': 'io.tmpfile()', 'kind': 'f' },
      \ { 'word': 'io.type()', 'kind': 'f' },
      \ { 'word': 'io.write()', 'kind': 'f' },
      \ { 'word': 'math.abs()', 'kind': 'f' },
      \ { 'word': 'math.acos()', 'kind': 'f' },
      \ { 'word': 'math.asin()', 'kind': 'f' },
      \ { 'word': 'math.atan()', 'kind': 'f' },
      \ { 'word': 'math.atan2()', 'kind': 'f' },
      \ { 'word': 'math.ceil()', 'kind': 'f' },
      \ { 'word': 'math.cos()', 'kind': 'f' },
      \ { 'word': 'math.cosh()', 'kind': 'f' },
      \ { 'word': 'math.deg()', 'kind': 'f' },
      \ { 'word': 'math.exp()', 'kind': 'f' },
      \ { 'word': 'math.floor()', 'kind': 'f' },
      \ { 'word': 'math.fmod()', 'kind': 'f' },
      \ { 'word': 'math.frexp()', 'kind': 'f' },
      \ { 'word': 'math.huge', 'kind': 'm' },
      \ { 'word': 'math.ldexp()', 'kind': 'f' },
      \ { 'word': 'math.log()', 'kind': 'f' },
      \ { 'word': 'math.log10()', 'kind': 'f' },
      \ { 'word': 'math.max()', 'kind': 'f' },
      \ { 'word': 'math.min()', 'kind': 'f' },
      \ { 'word': 'math.mod()', 'kind': 'f' },
      \ { 'word': 'math.modf()', 'kind': 'f' },
      \ { 'word': 'math.pi', 'kind': 'm' },
      \ { 'word': 'math.pow()', 'kind': 'f' },
      \ { 'word': 'math.rad()', 'kind': 'f' },
      \ { 'word': 'math.random()', 'kind': 'f' },
      \ { 'word': 'math.randomseed()', 'kind': 'f' },
      \ { 'word': 'math.sin()', 'kind': 'f' },
      \ { 'word': 'math.sinh()', 'kind': 'f' },
      \ { 'word': 'math.sqrt()', 'kind': 'f' },
      \ { 'word': 'math.tan()', 'kind': 'f' },
      \ { 'word': 'math.tanh()', 'kind': 'f' },
      \ { 'word': 'os.clock()', 'kind': 'f' },
      \ { 'word': 'os.date()', 'kind': 'f' },
      \ { 'word': 'os.difftime()', 'kind': 'f' },
      \ { 'word': 'os.execute()', 'kind': 'f' },
      \ { 'word': 'os.exit()', 'kind': 'f' },
      \ { 'word': 'os.getenv()', 'kind': 'f' },
      \ { 'word': 'os.remove()', 'kind': 'f' },
      \ { 'word': 'os.rename()', 'kind': 'f' },
      \ { 'word': 'os.setlocale()', 'kind': 'f' },
      \ { 'word': 'os.time()', 'kind': 'f' },
      \ { 'word': 'os.tmpname()', 'kind': 'f' },
      \ { 'word': 'package.config', 'kind': 'm' },
      \ { 'word': 'package.cpath', 'kind': 'm' },
      \ { 'word': 'package.loaded', 'kind': 'm' },
      \ { 'word': 'package.loaders', 'kind': 'm' },
      \ { 'word': 'package.loadlib()', 'kind': 'f' },
      \ { 'word': 'package.path', 'kind': 'm' },
      \ { 'word': 'package.preload', 'kind': 'm' },
      \ { 'word': 'package.seeall()', 'kind': 'f' },
      \ { 'word': 'string.byte()', 'kind': 'f' },
      \ { 'word': 'string.char()', 'kind': 'f' },
      \ { 'word': 'string.dump()', 'kind': 'f' },
      \ { 'word': 'string.find()', 'kind': 'f' },
      \ { 'word': 'string.format()', 'kind': 'f' },
      \ { 'word': 'string.gfind()', 'kind': 'f' },
      \ { 'word': 'string.gmatch()', 'kind': 'f' },
      \ { 'word': 'string.gsplit()', 'kind': 'f' },
      \ { 'word': 'string.gsub()', 'kind': 'f' },
      \ { 'word': 'string.len()', 'kind': 'f' },
      \ { 'word': 'string.lower()', 'kind': 'f' },
      \ { 'word': 'string.match()', 'kind': 'f' },
      \ { 'word': 'string.rep()', 'kind': 'f' },
      \ { 'word': 'string.reverse()', 'kind': 'f' },
      \ { 'word': 'string.sub()', 'kind': 'f' },
      \ { 'word': 'string.upper()', 'kind': 'f' },
      \ { 'word': 'table.concat()', 'kind': 'f' },
      \ { 'word': 'table.foreach()', 'kind': 'f' },
      \ { 'word': 'table.foreachi()', 'kind': 'f' },
      \ { 'word': 'table.getn()', 'kind': 'f' },
      \ { 'word': 'table.insert()', 'kind': 'f' },
      \ { 'word': 'table.maxn()', 'kind': 'f' },
      \ { 'word': 'table.remove()', 'kind': 'f' },
      \ { 'word': 'table.setn()', 'kind': 'f' },
      \ { 'word': 'table.sort()', 'kind': 'f' } ]

" Function signatures. {{{1
" Sources:
"  - http://www.lua.org/manual/5.1/manual.html#5
"  - http://w3.impa.br/~diego/software/luasocket/reference.html

let g:xolox#lua_data#signatures = {
      \ 'assert': 'assert(v [, message])',
      \ 'collectgarbage': 'collectgarbage(opt [, arg])',
      \ 'dofile': 'dofile(filename)',
      \ 'error': 'error(message [, level])',
      \ 'getfenv': 'getfenv([f])',
      \ 'getmetatable': 'getmetatable(object)',
      \ 'ipairs': 'ipairs(t)',
      \ 'load': 'load(func [, chunkname])',
      \ 'loadfile': 'loadfile([filename])',
      \ 'loadstring': 'loadstring(string [, chunkname])',
      \ 'next': 'next(table [, index])',
      \ 'pairs': 'pairs(t)',
      \ 'pcall': 'pcall(f, arg1, ...)',
      \ 'print': 'print(...)',
      \ 'rawequal': 'rawequal(v1, v2)',
      \ 'rawget': 'rawget(table, index)',
      \ 'rawset': 'rawset(table, index, value)',
      \ 'select': 'select(index, ...)',
      \ 'setfenv': 'setfenv(f, table)',
      \ 'setmetatable': 'setmetatable(table, metatable)',
      \ 'tonumber': 'tonumber(e [, base])',
      \ 'tostring': 'tostring(e)',
      \ 'type': 'type(v)',
      \ 'unpack': 'unpack(list [, i [, j]])',
      \ 'xpcall': 'xpcall(f, err)',
      \ 'coroutine.create': 'coroutine.create(f)',
      \ 'coroutine.resume': 'coroutine.resume(co [, val1, ...])',
      \ 'coroutine.running': 'coroutine.running()',
      \ 'coroutine.status': 'coroutine.status(co)',
      \ 'coroutine.wrap': 'coroutine.wrap(f)',
      \ 'coroutine.yield': 'coroutine.yield(...)',
      \ 'module': 'module(name [, ...])',
      \ 'require': 'require(modname)',
      \ 'package.loadlib': 'package.loadlib(libname, funcname)',
      \ 'package.seeall': 'package.seeall(module)',
      \ 'string.byte': 'string.byte(s [, i [, j]])',
      \ 'string.char': 'string.char(...)',
      \ 'string.dump': 'string.dump(function)',
      \ 'string.find': 'string.find(s, pattern [, init [, plain]])',
      \ 'string.format': 'string.format(formatstring, ...)',
      \ 'string.gmatch': 'string.gmatch(s, pattern)',
      \ 'string.gsub': 'string.gsub(s, pattern, repl [, n])',
      \ 'string.len': 'string.len(s)',
      \ 'string.lower': 'string.lower(s)',
      \ 'string.match': 'string.match(s, pattern [, init])',
      \ 'string.rep': 'string.rep(s, n)',
      \ 'string.reverse': 'string.reverse(s)',
      \ 'string.sub': 'string.sub(s, i [, j])',
      \ 'string.upper': 'string.upper(s)',
      \ 'table.concat': 'table.concat(table [, sep [, i [, j]]])',
      \ 'table.insert': 'table.insert(table, [pos,] value)',
      \ 'table.maxn': 'table.maxn(table)',
      \ 'table.remove': 'table.remove(table [, pos])',
      \ 'table.sort': 'table.sort(table [, comp])',
      \ 'math.abs': 'math.abs(x)',
      \ 'math.acos': 'math.acos(x)',
      \ 'math.asin': 'math.asin(x)',
      \ 'math.atan': 'math.atan(x)',
      \ 'math.atan2': 'math.atan2(y, x)',
      \ 'math.ceil': 'math.ceil(x)',
      \ 'math.cos': 'math.cos(x)',
      \ 'math.cosh': 'math.cosh(x)',
      \ 'math.deg': 'math.deg(x)',
      \ 'math.exp': 'math.exp(x)',
      \ 'math.floor': 'math.floor(x)',
      \ 'math.fmod': 'math.fmod(x, y)',
      \ 'math.frexp': 'math.frexp(x)',
      \ 'math.ldexp': 'math.ldexp(m, e)',
      \ 'math.log': 'math.log(x)',
      \ 'math.log10': 'math.log10(x)',
      \ 'math.max': 'math.max(x, ...)',
      \ 'math.min': 'math.min(x, ...)',
      \ 'math.modf': 'math.modf(x)',
      \ 'math.pow': 'math.pow(x, y)',
      \ 'math.rad': 'math.rad(x)',
      \ 'math.random': 'math.random([m [, n]])',
      \ 'math.randomseed': 'math.randomseed(x)',
      \ 'math.sin': 'math.sin(x)',
      \ 'math.sinh': 'math.sinh(x)',
      \ 'math.sqrt': 'math.sqrt(x)',
      \ 'math.tan': 'math.tan(x)',
      \ 'math.tanh': 'math.tanh(x)',
      \ 'io.close': 'io.close([file])',
      \ 'io.flush': 'io.flush()',
      \ 'io.input': 'io.input([file])',
      \ 'io.lines': 'io.lines([filename])',
      \ 'io.open': 'io.open(filename [, mode])',
      \ 'io.output': 'io.output([file])',
      \ 'io.popen': 'io.popen(prog [, mode])',
      \ 'io.read': 'io.read(...)',
      \ 'io.tmpfile': 'io.tmpfile()',
      \ 'io.type': 'io.type(obj)',
      \ 'io.write': 'io.write(...)',
      \ 'file:close': 'file:close()',
      \ 'file:flush': 'file:flush()',
      \ 'file:lines': 'file:lines()',
      \ 'file:read': 'file:read(...)',
      \ 'file:seek': 'file:seek([whence] [, offset])',
      \ 'file:setvbuf': 'file:setvbuf(mode [, size])',
      \ 'file:write': 'file:write(...)',
      \ 'os.clock': 'os.clock()',
      \ 'os.date': 'os.date([format [, time]])',
      \ 'os.difftime': 'os.difftime(t2, t1)',
      \ 'os.execute': 'os.execute([command])',
      \ 'os.exit': 'os.exit([code])',
      \ 'os.getenv': 'os.getenv(varname)',
      \ 'os.remove': 'os.remove(filename)',
      \ 'os.rename': 'os.rename(oldname, newname)',
      \ 'os.setlocale': 'os.setlocale(locale [, category])',
      \ 'os.time': 'os.time([table])',
      \ 'os.tmpname': 'os.tmpname()',
      \ 'debug.debug': 'debug.debug()',
      \ 'debug.getfenv': 'debug.getfenv(o)',
      \ 'debug.gethook': 'debug.gethook([thread])',
      \ 'debug.getinfo': 'debug.getinfo([thread,] function [, what])',
      \ 'debug.getlocal': 'debug.getlocal([thread,] level, local)',
      \ 'debug.getmetatable': 'debug.getmetatable(object)',
      \ 'debug.getregistry': 'debug.getregistry()',
      \ 'debug.getupvalue': 'debug.getupvalue(func, up)',
      \ 'debug.setfenv': 'debug.setfenv(object, table)',
      \ 'debug.sethook': 'debug.sethook([thread,] hook, mask [, count])',
      \ 'debug.setlocal': 'debug.setlocal([thread,] level, local, value)',
      \ 'debug.setmetatable': 'debug.setmetatable(object, table)',
      \ 'debug.setupvalue': 'debug.setupvalue(func, up, value)',
      \ 'debug.traceback': 'debug.traceback([thread,] [message] [, level])',
      \
      \ 'ftp.get': 'ftp.get(url)',
      \ 'ftp.put': 'ftp.put(url, content)',
      \ 'http.request': 'http.request(url [, body])',
      \ 'ltn12.filter.chain': 'ltn12.filter.chain(filter1, filter2 [, ... filterN])',
      \ 'ltn12.filter.cycle': 'ltn12.filter.cycle(low [, ctx, extra])',
      \ 'ltn12.pump.all': 'ltn12.pump.all(source, sink)',
      \ 'ltn12.pump.step': 'ltn12.pump.step(source, sink)',
      \ 'ltn12.sink.chain': 'ltn12.sink.chain(filter, sink)',
      \ 'ltn12.sink.error': 'ltn12.sink.error(message)',
      \ 'ltn12.sink.file': 'ltn12.sink.file(handle, message)',
      \ 'ltn12.sink.simplify': 'ltn12.sink.simplify(sink)',
      \ 'ltn12.sink.table': 'ltn12.sink.table([table])',
      \ 'ltn12.source.cat': 'ltn12.source.cat(source1 [, source2, ..., sourceN])',
      \ 'ltn12.source.chain': 'ltn12.source.chain(source, filter)',
      \ 'ltn12.source.empty': 'ltn12.source.empty()',
      \ 'ltn12.source.error': 'ltn12.source.error(message)',
      \ 'ltn12.source.file': 'ltn12.source.file(handle, message)',
      \ 'ltn12.source.simplify': 'ltn12.source.simplify(source)',
      \ 'ltn12.source.string': 'ltn12.source.string(string)',
      \ 'mime.decode': "mime.decode('base64' or 'quoted-printable')",
      \ 'mime.encode': "mime.encode('base64' or 'quoted-printable' [, mode])",
      \ 'mime.normalize': 'mime.normalize([marker])',
      \ 'mime.wrap': "mime.wrap('base64' or 'quoted-printable' or 'text' [, length])",
      \ 'smtp.message': 'smtp.message(mesgt)',
      \ 'socket.bind': 'socket.bind(address, port [, backlog])',
      \ 'socket.connect': 'socket.connect(address, port [, locaddr, locport])',
      \ 'socket.dns.tohostname': 'socket.dns.tohostname(address)',
      \ 'socket.dns.toip': 'socket.dns.toip(address)',
      \ 'socket.newtry': 'socket.newtry(finalizer)',
      \ 'socket.protect': 'socket.protect(func)',
      \ 'socket.select': 'socket.select(recvt, sendt [, timeout])',
      \ 'socket.sink': 'socket.sink(mode, socket)',
      \ 'socket.skip': 'socket.skip(d [, ret1, ret2 ... retN])',
      \ 'socket.sleep': 'socket.sleep(time)',
      \ 'socket.source': 'socket.source(mode, socket [, length])',
      \ 'socket.try': 'socket.try(ret1 [, ret2 ... retN])',
      \ 'url.absolute': 'url.absolute(base, relative)',
      \ 'url.build': 'url.build(parsed_url)',
      \ 'url.build_path': 'url.build_path(segments, unsafe)',
      \ 'url.escape': 'url.escape(content)',
      \ 'url.parse': 'url.parse(url, default)',
      \ 'url.parse_path': 'url.parse_path(path)',
      \ 'url.unescape': 'url.unescape(content)' }

" }}}

" Restore compatibility options.
let &cpo = s:cpo_save
unlet s:cpo_save

" vim: ts=2 sw=2 et
